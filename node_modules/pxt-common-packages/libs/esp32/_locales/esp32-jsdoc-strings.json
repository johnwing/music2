{
  "esp32.NinaController.MACaddress": "A bytearray containing the MAC address of the ESP32",
  "esp32.NinaController.connect": "Uses RSSID and password in settings to connect to a compatible AP",
  "esp32.NinaController.firmwareVersion": "A string of the firmware version on the ESP32",
  "esp32.NinaController.hostbyName": "Convert a hostname to a packed 4-byte IP address. Returns\na 4 bytearray",
  "esp32.NinaController.ping": "Ping a destination IP address or hostname, with a max time-to-live\n(ttl). Returns a millisecond timing value",
  "esp32.NinaController.reset": "Hard reset the ESP32 using the reset pin",
  "esp32.NinaController.scanNetworks": "Scan for visible access points, returns a list of access point details.\nReturns a list of dictionaries with 'ssid', 'rssi' and 'encryption' entries,\none for each AP found",
  "esp32.NinaController.setAnalogWrite": "Set the analog output value of pin, using PWM.\n:param int pin: ESP32 GPIO pin to write to.\n:param float value: 0=off 1.0=full on",
  "esp32.NinaController.setDigitalWrite": "Set the digital output value of pin.\n:param int pin: ESP32 GPIO pin to write to.\n:param bool value: Value for the pin.",
  "esp32.NinaController.setESPdebug": "Enable/disable debug mode on the ESP32. Debug messages will be\nwritten to the ESP32's UART.",
  "esp32.NinaController.setPinMode": "Set the io mode for a GPIO pin.\n:param int pin: ESP32 GPIO pin to set.\n:param value: direction for pin, digitalio.Direction or integer (0=input, 1=output).",
  "esp32.NinaController.socket": "Request a socket from the ESP32, will allocate and return a number that\ncan then be passed to the other socket commands",
  "esp32.NinaController.socketAvailable": "Determine how many bytes are waiting to be read on the socket",
  "esp32.NinaController.socketClose": "Close a socket using the ESP32's internal reference number",
  "esp32.NinaController.socketConnect": "Open and verify we connected a socket to a destination IP address or hostname\nusing the ESP32's internal reference number. By default we use\n'conn_mode' TCP_MODE but can also use UDP_MODE or TLS_MODE (dest must\nbe hostname for TLS_MODE!)",
  "esp32.NinaController.socketOpen": "Open a socket to a destination IP address or hostname\nusing the ESP32's internal reference number. By default we use\n'conn_mode' TCP_MODE but can also use UDP_MODE or TLS_MODE\n(dest must be hostname for TLS_MODE!)",
  "esp32.NinaController.socketRead": "Read up to 'size' bytes from the socket number. Returns a bytearray",
  "esp32.NinaController.socketStatus": "Get the socket connection status, can be SOCKET_CLOSED, SOCKET_LISTEN,\nSOCKET_SYN_SENT, SOCKET_SYN_RCVD, SOCKET_ESTABLISHED, SOCKET_FIN_WAIT_1,\nSOCKET_FIN_WAIT_2, SOCKET_CLOSE_WAIT, SOCKET_CLOSING, SOCKET_LAST_ACK, or\nSOCKET_TIME_WAIT",
  "esp32.NinaController.socketWrite": "Write the bytearray buffer to a socket",
  "esp32.NinaController.socket_connected": "Test if a socket is connected to the destination, returns boolean true/false",
  "esp32.NinaController.wifiSetEntenable": "Enables WPA2 Enterprise mode",
  "esp32.NinaController.wifiSetEntidentity": "Sets the WPA2 Enterprise anonymous identity",
  "esp32.NinaController.wifiSetEntpassword": "Sets the desired WPA2 Enterprise password",
  "esp32.NinaController.wifiSetEntusername": "Sets the desired WPA2 Enterprise username",
  "esp32.NinaController.wifiSetNetwork": "Tells the ESP32 to set the access point to the given ssid",
  "esp32.NinaController.wifiSetPassphrase": "Sets the desired access point ssid and passphrase"
}