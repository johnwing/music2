"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nodeutil = require("./nodeutil");
var fs = require("fs");
var path = require("path");
function crowdinCredentialsAsync() {
    var prj = pxt.appTarget.appTheme.crowdinProject;
    var branch = pxt.appTarget.appTheme.crowdinBranch;
    if (!prj) {
        pxt.log("crowdin upload skipped, Crowdin project missing in target theme");
        return Promise.resolve(undefined);
    }
    var key;
    if (pxt.crowdin.testMode)
        key = pxt.crowdin.TEST_KEY;
    else
        key = process.env[pxt.crowdin.KEY_VARIABLE];
    if (!key) {
        pxt.log("Crowdin operation skipped: '" + pxt.crowdin.KEY_VARIABLE + "' variable is missing");
        return undefined;
    }
    return Promise.resolve({ prj: prj, key: key, branch: branch });
}
function uploadTargetTranslationsAsync(parsed) {
    var uploadDocs = parsed && !!parsed.flags["docs"];
    if (parsed && !!parsed.flags["test"])
        pxt.crowdin.setTestMode();
    return internalUploadTargetTranslationsAsync(uploadDocs);
}
exports.uploadTargetTranslationsAsync = uploadTargetTranslationsAsync;
function internalUploadTargetTranslationsAsync(uploadDocs) {
    pxt.log("retrieving Crowdin credentials...");
    return crowdinCredentialsAsync()
        .then(function (cred) {
        if (!cred)
            return Promise.resolve();
        pxt.log("got Crowdin credentials");
        var crowdinDir = pxt.appTarget.id;
        if (crowdinDir == "core") {
            if (!uploadDocs) {
                pxt.log('missing --docs flag, skipping');
                return Promise.resolve();
            }
            pxt.log("uploading core translations...");
            return uploadDocsTranslationsAsync("docs", crowdinDir, cred.branch, cred.prj, cred.key)
                .then(function () { return uploadDocsTranslationsAsync("common-docs", crowdinDir, cred.branch, cred.prj, cred.key); });
        }
        else {
            pxt.log("uploading target translations...");
            return execCrowdinAsync("upload", "built/target-strings.json", crowdinDir)
                .then(function () { return fs.existsSync("built/sim-strings.json") ? execCrowdinAsync("upload", "built/sim-strings.json", crowdinDir) : Promise.resolve(); })
                .then(function () { return uploadBundledTranslationsAsync(crowdinDir, cred.branch, cred.prj, cred.key); })
                .then(function () {
                if (uploadDocs) {
                    pxt.log("uploading docs...");
                    return uploadDocsTranslationsAsync("docs", crowdinDir, cred.branch, cred.prj, cred.key)
                        .then(function () { return Promise.all(pxt.appTarget.bundleddirs
                        .filter(function (pkgDir) { return nodeutil.existsDirSync(path.join(pkgDir, "docs")); })
                        .map(function (pkgDir) { return uploadDocsTranslationsAsync(path.join(pkgDir, "docs"), crowdinDir, cred.branch, cred.prj, cred.key); })).then(function () {
                        pxt.log("docs uploaded");
                    }); });
                }
                pxt.log("skipping docs upload (not a release)");
                return Promise.resolve();
            });
        }
    });
}
exports.internalUploadTargetTranslationsAsync = internalUploadTargetTranslationsAsync;
function uploadDocsTranslationsAsync(srcDir, crowdinDir, branch, prj, key) {
    pxt.log("uploading from " + srcDir + " to " + crowdinDir + " under project " + prj + "/" + (branch || ""));
    var ignoredDirectories = {};
    nodeutil.allFiles(srcDir).filter(function (d) { return nodeutil.fileExistsSync(path.join(path.dirname(d), ".crowdinignore")); }).forEach(function (f) { return ignoredDirectories[path.dirname(f)] = true; });
    var ignoredDirectoriesList = Object.keys(ignoredDirectories);
    var todo = nodeutil.allFiles(srcDir).filter(function (f) { return /\.md$/.test(f) && !/_locales/.test(f); }).reverse();
    var knownFolders = {};
    var ensureFolderAsync = function (crowdd) {
        if (!knownFolders[crowdd]) {
            knownFolders[crowdd] = true;
            pxt.log("creating folder " + crowdd);
            return pxt.crowdin.createDirectoryAsync(branch, prj, key, crowdd);
        }
        return Promise.resolve();
    };
    var nextFileAsync = function (f) {
        if (!f)
            return Promise.resolve();
        var crowdf = path.join(crowdinDir, f);
        var crowdd = path.dirname(crowdf);
        // check if file should be ignored
        if (ignoredDirectoriesList.filter(function (d) { return path.dirname(f).indexOf(d) == 0; }).length > 0) {
            pxt.log("skpping " + f + " because of .crowdinignore file");
            return nextFileAsync(todo.pop());
        }
        var data = fs.readFileSync(f, 'utf8');
        pxt.log("uploading " + f + " to " + crowdf);
        return ensureFolderAsync(crowdd)
            .then(function () { return pxt.crowdin.uploadTranslationAsync(branch, prj, key, crowdf, data); })
            .then(function () { return nextFileAsync(todo.pop()); });
    };
    return ensureFolderAsync(path.join(crowdinDir, srcDir))
        .then(function () { return nextFileAsync(todo.pop()); });
}
function uploadBundledTranslationsAsync(crowdinDir, branch, prj, key) {
    var todo = [];
    pxt.appTarget.bundleddirs.forEach(function (dir) {
        var locdir = path.join(dir, "_locales");
        if (fs.existsSync(locdir))
            fs.readdirSync(locdir)
                .filter(function (f) { return /strings\.json$/i.test(f); })
                .forEach(function (f) { return todo.push(path.join(locdir, f)); });
    });
    pxt.log("uploading bundled translations to Crowdin (" + todo.length + " files)");
    var nextFileAsync = function () {
        var f = todo.pop();
        if (!f)
            return Promise.resolve();
        var data = JSON.parse(fs.readFileSync(f, 'utf8'));
        var crowdf = path.join(crowdinDir, path.basename(f));
        pxt.log("uploading " + f + " to " + crowdf);
        return pxt.crowdin.uploadTranslationAsync(branch, prj, key, crowdf, JSON.stringify(data))
            .then(nextFileAsync);
    };
    return nextFileAsync();
}
function downloadTargetTranslationsAsync(parsed) {
    var name = (parsed && parsed.args[0]) || "";
    var crowdinDir = pxt.appTarget.id;
    return crowdinCredentialsAsync()
        .then(function (cred) {
        if (!cred)
            return Promise.resolve();
        return downloadFilesAsync(cred, ["sim-strings.json"], "sim")
            .then(function () { return downloadFilesAsync(cred, ["target-strings.json"], "target"); })
            .then(function () {
            var files = [];
            pxt.appTarget.bundleddirs
                .filter(function (dir) { return !name || dir == "libs/" + name; })
                .forEach(function (dir) {
                var locdir = path.join(dir, "_locales");
                if (fs.existsSync(locdir))
                    fs.readdirSync(locdir)
                        .filter(function (f) { return /\.json$/i.test(f); })
                        .forEach(function (f) { return files.push(path.join(locdir, f)); });
            });
            return downloadFilesAsync(cred, files, "bundled");
        });
    });
    function downloadFilesAsync(cred, todo, outputName) {
        var locs = {};
        var nextFileAsync = function () {
            var f = todo.pop();
            if (!f) {
                return Promise.resolve();
            }
            var errors = {};
            var fn = path.basename(f);
            var crowdf = path.join(crowdinDir, fn);
            var locdir = path.dirname(f);
            var projectdir = path.dirname(locdir);
            pxt.log("downloading " + crowdf);
            pxt.debug("projectdir: " + projectdir);
            return pxt.crowdin.downloadTranslationsAsync(cred.branch, cred.prj, cred.key, crowdf, { translatedOnly: true, validatedOnly: true })
                .then(function (data) {
                Object.keys(data)
                    .filter(function (lang) { return Object.keys(data[lang]).some(function (k) { return !!data[lang][k]; }); })
                    .forEach(function (lang) {
                    var dataLang = data[lang];
                    var langTranslations = stringifyTranslations(dataLang);
                    if (!langTranslations)
                        return;
                    // validate translations
                    if (/-strings\.json$/.test(fn) && !/jsdoc-strings\.json$/.test(fn)) {
                        // block definitions
                        Object.keys(dataLang).forEach(function (id) {
                            var tr = dataLang[id];
                            pxt.blocks.normalizeBlock(tr, function (err) {
                                var errid = fn + "." + lang;
                                errors[fn + "." + lang] = 1;
                                pxt.log("error " + errid + ": " + err);
                            });
                        });
                    }
                    // merge translations
                    var strings = locs[lang];
                    if (!strings)
                        strings = locs[lang] = {};
                    Object.keys(dataLang)
                        .filter(function (k) { return !!dataLang[k] && !strings[k]; })
                        .forEach(function (k) { return strings[k] = dataLang[k]; });
                });
                var errorIds = Object.keys(errors);
                if (errorIds.length) {
                    pxt.log(errorIds.length + " errors");
                    errorIds.forEach(function (blockid) { return pxt.log("error in " + blockid); });
                    pxt.reportError("loc.errors", "invalid translation", errors);
                }
                return nextFileAsync();
            });
        };
        return nextFileAsync()
            .then(function () {
            Object.keys(locs).forEach(function (lang) {
                var tf = path.join("sim/public/locales/" + lang + "/" + outputName + "-strings.json");
                pxt.log("writing " + tf);
                var dataLang = locs[lang];
                var langTranslations = stringifyTranslations(dataLang);
                nodeutil.writeFileSync(tf, langTranslations, { encoding: "utf8" });
            });
        });
    }
}
exports.downloadTargetTranslationsAsync = downloadTargetTranslationsAsync;
function stringifyTranslations(strings) {
    var trg = {};
    Object.keys(strings).sort().forEach(function (k) {
        var v = strings[k].trim();
        if (v)
            trg[k] = v;
    });
    if (Object.keys(trg).length == 0)
        return undefined;
    else
        return JSON.stringify(trg, null, 2);
}
function execCrowdinAsync(cmd) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    pxt.log("executing Crowdin command " + cmd + "...");
    var prj = pxt.appTarget.appTheme.crowdinProject;
    if (!prj) {
        console.log("crowdin operation skipped, crowdin project not specified in pxtarget.json");
        return Promise.resolve();
    }
    var branch = pxt.appTarget.appTheme.crowdinBranch;
    return crowdinCredentialsAsync()
        .then(function (crowdinCredentials) {
        if (!crowdinCredentials)
            return Promise.resolve();
        var key = crowdinCredentials.key;
        cmd = cmd.toLowerCase();
        if (!args[0] && (cmd != "clean" && cmd != "stats"))
            throw new Error(cmd == "status" ? "language missing" : "filename missing");
        switch (cmd) {
            case "stats": return statsCrowdinAsync(prj, key, args[0]);
            case "clean": return cleanCrowdinAsync(prj, key, args[0] || "docs");
            case "upload": return uploadCrowdinAsync(branch, prj, key, args[0], args[1]);
            case "download": {
                if (!args[1])
                    throw new Error("output path missing");
                var fn_1 = path.basename(args[0]);
                return pxt.crowdin.downloadTranslationsAsync(branch, prj, key, args[0], { translatedOnly: true, validatedOnly: true })
                    .then(function (r) {
                    Object.keys(r).forEach(function (k) {
                        var rtranslations = stringifyTranslations(r[k]);
                        if (!rtranslations)
                            return;
                        nodeutil.mkdirP(path.join(args[1], k));
                        var outf = path.join(args[1], k, fn_1);
                        console.log("writing " + outf);
                        nodeutil.writeFileSync(outf, rtranslations, { encoding: "utf8" });
                    });
                });
            }
            default: throw new Error("unknown command");
        }
    });
}
exports.execCrowdinAsync = execCrowdinAsync;
function cleanCrowdinAsync(prj, key, dir) {
    var p = pxt.appTarget.id + "/" + dir;
    return pxt.crowdin.listFilesAsync(prj, key, p)
        .then(function (files) {
        files.filter(function (f) { return !nodeutil.fileExistsSync(f.fullName.substring(pxt.appTarget.id.length + 1)); })
            .forEach(function (f) { return pxt.log("crowdin: dead file: " + (f.branch ? f.branch + "/" : "") + f.fullName); });
    });
}
function statsCrowdinAsync(prj, key, preferredLang) {
    pxt.log("collecting crowdin stats for " + prj + " " + (preferredLang ? "for language " + preferredLang : "all languages"));
    console.log("context\t language\t translated%\t approved%\t phrases\t translated\t approved");
    var fn = "crowdinstats.csv";
    var headers = 'sep=\t\r\n';
    headers += "id\t file\t language\t phrases\t translated\t approved\r\n";
    nodeutil.writeFileSync(fn, headers, { encoding: "utf8" });
    return pxt.crowdin.projectInfoAsync(prj, key)
        .then(function (info) {
        if (!info)
            throw new Error("info failed");
        var languages = info.languages;
        // remove in-context language
        languages = languages.filter(function (l) { return l.code != ts.pxtc.Util.TRANSLATION_LOCALE; });
        if (preferredLang)
            languages = languages.filter(function (lang) { return lang.code.toLowerCase() == preferredLang.toLowerCase(); });
        return Promise.all(languages.map(function (lang) { return langStatsCrowdinAsync(prj, key, lang.code); }));
    }).then(function () {
        console.log("stats written to " + fn);
    });
    function langStatsCrowdinAsync(prj, key, lang) {
        return pxt.crowdin.languageStatsAsync(prj, key, lang)
            .then(function (stats) {
            var uiphrases = 0;
            var uitranslated = 0;
            var uiapproved = 0;
            var corephrases = 0;
            var coretranslated = 0;
            var coreapproved = 0;
            var phrases = 0;
            var translated = 0;
            var approved = 0;
            var r = '';
            stats.forEach(function (stat) {
                var cfn = "" + (stat.branch ? stat.branch + "/" : "") + stat.fullName;
                r += stat.id + "\t " + cfn + "\t " + lang + "\t " + stat.phrases + "\t " + stat.translated + "\t " + stat.approved + "\r\n";
                if (stat.fullName == "strings.json") {
                    uiapproved += Number(stat.approved);
                    uitranslated += Number(stat.translated);
                    uiphrases += Number(stat.phrases);
                }
                else if (/core-strings\.json$/.test(stat.fullName)) {
                    coreapproved += Number(stat.approved);
                    coretranslated += Number(stat.translated);
                    corephrases += Number(stat.phrases);
                }
                else if (/-strings\.json$/.test(stat.fullName)) {
                    approved += Number(stat.approved);
                    translated += Number(stat.translated);
                    phrases += Number(stat.phrases);
                }
            });
            fs.appendFileSync(fn, r, { encoding: "utf8" });
            console.log("ui\t " + lang + "\t " + ((uitranslated / uiphrases * 100) >> 0) + "%\t " + ((uiapproved / uiphrases * 100) >> 0) + "%\t " + uiphrases + "\t " + uitranslated + "\t " + uiapproved);
            console.log("core\t " + lang + "\t " + ((coretranslated / corephrases * 100) >> 0) + "%\t " + ((coreapproved / corephrases * 100) >> 0) + "%\t " + corephrases + "\t " + coretranslated + "\t " + coreapproved);
            console.log("blocks\t " + lang + "\t " + ((translated / phrases * 100) >> 0) + "%\t " + ((approved / phrases * 100) >> 0) + "%\t " + phrases + "\t " + translated + "\t " + approved);
        });
    }
}
function uploadCrowdinAsync(branch, prj, key, p, dir) {
    var fn = path.basename(p);
    if (dir)
        fn = dir.replace(/[\\/]*$/g, '') + '/' + fn;
    var data = JSON.parse(fs.readFileSync(p, "utf8"));
    pxt.log("upload " + fn + " (" + Object.keys(data).length + " strings) to https://crowdin.com/project/" + prj + (branch ? "?branch=" + branch : ''));
    return pxt.crowdin.uploadTranslationAsync(branch, prj, key, fn, JSON.stringify(data));
}
