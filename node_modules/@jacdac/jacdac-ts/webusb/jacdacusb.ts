/// <reference path="../built/jacdac.d.ts" />

namespace jacdac.webusb {

const IFACE_CLASS = 0xDC;
const IFACE_SUBCLASS = 0x08;
const IFACE_PROTO = 0x00;
const JD_PACKET_RAM_SIZE = 260;

const USB_JACDAC_REQ_INIT = 0x11;
const USB_JACDAC_REQ_DIAGNOSTICS = 0x22;
const USB_JACDAC_REQ_DIAGNOSTICS_LEN = 28;

/**
struct USBJACDACDiagnostics {
    uint32_t bus_state;
    uint32_t bus_lo_error;
    uint32_t bus_uart_error;
    uint32_t bus_timeout_error;
    uint32_t packets_sent;
    uint32_t packets_received;
}
**/

export const usbVendors: USBDeviceFilter[] = [
    { vendorId: 0x0483, productId: 0x5799 }, // STM Arcade
    { vendorId: 0x03EB, productId: 0x2402 }  // Atmel Circuit Playground Express
];

export async function requestDevice(): Promise<USBManager> {
    const device = await navigator.usb.requestDevice({
        filters: usbVendors
    })
    // no connection
    if (!device) return undefined;

    const manager = await USBManager.connect(device);
    return manager;
}

export class USBManager implements jacdac.JDPhysicalLayer
{
    initialised: boolean;
    conn: USBDevice;
    endpoints: USBEndpoint[];
    ifaceNumber: number;
    private _diagnostics: boolean;

    onDataWritten: (res: USBOutTransferResult) => void;
    onDataReceived: (res: USBInTransferResult) => void;
    onDiagnosticsUpdated: (res: JDDiagnostics) => void;

    private getEpNum(inOut:string) : number
    {
        for (let endpoint of this.endpoints)
        {
            if (endpoint.direction == inOut)
                return endpoint.endpointNumber;
        }

        return -1;
    }

    static async connect(device: USBDevice): Promise<USBManager> {
        await device.open();
        await device.selectConfiguration(1);
        const manager = new USBManager(device);
        await manager.initialise();
        return manager;
    }

    private async initialise()
    {
        let setup : USBControlTransferParameters ={
            requestType: "class",
            recipient: "interface",
            request: USB_JACDAC_REQ_INIT,
            index: this.ifaceNumber,
            value:1 // any non-zero value will cause the device to begin streaming.
        }

        await this.conn.claimInterface(this.ifaceNumber)
        console.log("CLAIMED ", this.ifaceNumber);

        console.log("send setup: ",setup);

        let res = await this.conn.controlTransferOut(setup)
        console.log("SETUP OUTPUT",res);

        if (res.status != "ok")
            throw new Error("USB Driver error")

        this.readForever();

        this.initialised = true;
    }

    private constructor(device: USBDevice)
    {
        this.initialised = false;
        this._diagnostics = false;
        this.conn = device;
        this.ifaceNumber = -1;
        for (let iface of device.configuration.interfaces)
        {
            for (let alternate of iface.alternates)
            {
                if (alternate.interfaceClass == IFACE_CLASS && alternate.interfaceSubclass == IFACE_SUBCLASS && alternate.interfaceProtocol == IFACE_PROTO)
                {
                    this.ifaceNumber = iface.interfaceNumber;
                    this.endpoints = alternate.endpoints;
                    break;
                }
            }
        }

        if (this.endpoints.length != 2 || this.ifaceNumber == -1)
            throw new Error("jacdac debugger endpoint mismatch");

        this.onDataReceived = this.dataReceivedHandler.bind(this);
    }

    private dataReceivedHandler(res: USBInTransferResult) {
        const buf = new Uint8Array(res.data.buffer);
        const jbuf = jacdac.Buffer.createBufferFromUint8(buf);
        const pkt = new jacdac.JDPacket(jbuf);
        jacdac.JACDAC.instance.routePacket(pkt);
    }

    private sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    private async readForever()
    {
        let loop = (): void => {
            this.read(JD_PACKET_RAM_SIZE).then(res => {
                if (res.status == "ok")
                {
                    this.onDataReceived(res);
                    loop()
                } else {
                    // throttle down if no data coming
                    this.sleep(10).then(loop)
                }
            }, err => {
                console.log("read err", err);
                this.sleep(10).then(loop)
            })
        }
        loop()
    }

    get diagnostics() {
        return this._diagnostics;
    }

    set diagnostics(value: boolean) {
        if (this._diagnostics != value) {
            this._diagnostics = value;
            if (this._diagnostics)
                this.readDiagnosticsForever();
        }
    }

    private async readDiagnosticsForever()
    {
        let loop = (): void => {
            if (!this._diagnostics) return; // not running anymore
            // console.log("r",this);
            this.readDiagnostics().then(res => {
                if (res.status == "ok")
                {
                    const diag = new jacdac.JDDiagnostics(jacdac.Buffer.createBufferFromUint8(new Uint8Array(res.data.buffer)));
                    this.onDiagnosticsUpdated(diag);
                }

                this.sleep(500).then(loop)
            }, err => {
                console.log("read err", err);
                this.sleep(500).then(loop)
            })
        }
        loop()
    }

    private readDiagnostics() :PromiseLike<USBInTransferResult>
    {
        let setup : USBControlTransferParameters ={
            requestType: "class",
            recipient: "interface",
            request: USB_JACDAC_REQ_DIAGNOSTICS,
            index: this.ifaceNumber,
            value:0
        }
        // console.log("readdiag", Date.now());
        let final = (res: USBInTransferResult) => {
            // console.log("FINAL!!!");
            return res
        }
        // console.log("contin ",setup,USB_JACDAC_REQ_DIAGNOSTICS_LEN);
        return this.conn.controlTransferIn(setup, USB_JACDAC_REQ_DIAGNOSTICS_LEN).then(final);
    }

    read(size: number) : PromiseLike<USBInTransferResult>
    {
        // console.log("read", Date.now());
        let final = (res: USBInTransferResult) => {
            if (res.status != "ok")
                return this.read(size);
            return res
        }
        return this.conn.transferIn(this.getEpNum("in"), size).then(final);
    }

    writeBuffer(buf: jacdac.Buffer) : PromiseLike<USBOutTransferResult>
    {
        // console.log("USB WRITE!!!", buf, buf.toUint8());
        let num = this.getEpNum("out");
        return this.conn.transferOut(num, buf.toUint8()).then(result => {/*console.log("write res:" ,result);*/ return result});
    }

    isConnected() : boolean
    {
        return this.initialised;
    }
}

}